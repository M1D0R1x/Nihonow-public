{% extends 'base.html' %}
{% load static %}
{% block title %}Flashcard Dojo {{ competition.code }} - Nihonow{% endblock %}
{% block content %}
<div class="container my-5">
    <h2 style="color: #00796b;">Flashcard Dojo: {{ competition.code }}</h2>
    <p>Deck: {{ competition.deck|title }} - {{ competition.subtype|title }}</p>
    {% if competition.timer_minutes %}
        <p id="timer">Time Left: {{ competition.timer_minutes }}:00</p>
    {% endif %}

    {% if is_host %}
        <div id="waiting-room" {% if competition.is_started %}style="display:none;"{% endif %}>
            <p>Waiting for players... (<span id="player-count">{{ participants.count }}</span>/{{ competition.max_players }})</p>
            <form id="start-form" action="{% url 'start_competition' competition_id=competition.id %}" method="POST">
                {% csrf_token %}
                <button type="submit" id="start-btn" class="btn" style="background-color: #00796b; color: white;" {% if participants.count == 0 %}disabled{% endif %}>Start Competition</button>
            </form>
        </div>
        <div id="leaderboard" class="mt-4">
            <h3>Leaderboard</h3>
            <table class="table">
                <thead><tr><th>Rank</th><th>Username</th><th>Points</th><th>Accuracy</th></tr></thead>
                <tbody id="leaderboard-body">
                    {% for p in participants %}
                        <tr><td>{{ forloop.counter }}</td><td>{{ p.user.username }}</td><td>{{ p.score }}</td><td>{{ p.accuracy|floatformat:1 }}%</td></tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    {% else %}
        <div id="waiting-message" {% if competition.is_started %}style="display:none;"{% endif %}>
            <p>Waiting for the host to start the competition...</p>
        </div>
        <div id="flashcard-container" class="text-center" {% if not competition.is_started %}style="display:none;"{% endif %}>
            <div id="flashcard" class="card mx-auto" style="width: 18rem;">
                <div class="card-inner" style="transition: transform 0.5s;">
                    <div class="card-front">?</div>
                    <div class="card-back"></div>
                </div>
            </div>
            <div id="options" class="mt-3" style="display:none;"></div>
            <p id="card-timer"></p>
        </div>
    {% endif %}
    <div id="countdown" class="text-center" style="display:none;"></div>
    <div id="error-message" class="text-center" style="display:none; color: red;"></div>
</div>

<script id="deck_data" type="application/json">
    {{ deck_data|safe }}
</script>

<script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
<script type="text/javascript">
    // Initialize Ably with the API key (for local testing only)
    const ably = new Ably.Realtime({
        key: '{{ ably_api_key }}'
    });
    const isHost = {{ is_host|lower }};
    let deckData, timer, currentCard;

    // Load deck data
    try {
        deckData = JSON.parse(document.getElementById('deck_data').textContent);
        console.log('Deck data loaded:', deckData);
    } catch (error) {
        console.error('Failed to parse deck data:', error);
        showError('An error occurred loading the game data. Please refresh the page.');
    }

    // Dynamic timer countdown
    if ({{ competition.timer_minutes|default:0 }}) {
        let timeLeft = {{ competition.timer_minutes }} * 60;
        const timerDisplay = document.getElementById('timer');
        const gameTimer = setInterval(() => {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.innerText = `Time Left: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            timeLeft--;
            if (timeLeft < 0) {
                clearInterval(gameTimer);
                timerDisplay.innerText = 'Timeâ€™s Up!';
                // Notify game over
                if (isHost) {
                    const competitionChannel = ably.channels.get('competition-{{ competition.id }}');
                    competitionChannel.publish('game-over', {});
                }
            }
        }, 1000);
    }

    // Ably channel for this competition
    const competitionChannel = ably.channels.get('competition-{{ competition.id }}');

    // Handle Ably connection
    ably.connection.on('connected', () => {
        console.log('Connected to Ably');
    });

    ably.connection.on('failed', (error) => {
        console.error('Ably connection failed:', error);
        showError('Failed to connect to the server. Retrying in 2 seconds...');
        setTimeout(() => location.reload(), 2000);
    });

    // Subscribe to competition events
    competitionChannel.subscribe('user-joined', (message) => {
        console.log('User joined:', message.data);
        const playerCount = document.getElementById('player-count');
        playerCount.innerText = parseInt(playerCount.innerText) + 1;
        if (isHost && parseInt(playerCount.innerText) > 0) {
            document.getElementById('start-btn').disabled = false;
        }
        // Update leaderboard
        competitionChannel.publish('request-leaderboard', {});
    });

    competitionChannel.subscribe('competition-started', (message) => {
        console.log('Competition started:', message.data);
        const countdownDiv = document.getElementById('countdown');
        let countdown = 3;
        countdownDiv.style.display = 'block';
        const countdownTimer = setInterval(() => {
            if (countdown > 0) {
                countdownDiv.innerText = `Starting in ${countdown}s`;
                countdown--;
            } else {
                countdownDiv.innerText = 'Go!';
                setTimeout(() => {
                    countdownDiv.style.display = 'none';
                    if (isHost) {
                        document.getElementById('waiting-room').style.display = 'none';
                        startGame();
                    } else {
                        document.getElementById('waiting-message').style.display = 'none';
                        document.getElementById('flashcard-container').style.display = 'block';
                    }
                }, 1000);
                clearInterval(countdownTimer);
            }
        }, 1000);
    });

    competitionChannel.subscribe('card', (message) => {
        console.log('New card:', message.data);
        showCard(message.data.card, message.data.flip_time, message.data.answer_time);
    });

    competitionChannel.subscribe('score-update', (message) => {
        console.log('Score update:', message.data);
        competitionChannel.publish('request-leaderboard', {});
    });

    competitionChannel.subscribe('leaderboard', (message) => {
        console.log('Leaderboard update:', message.data);
        updateLeaderboard(message.data);
    });

    competitionChannel.subscribe('game-over', (message) => {
        console.log('Game over');
        document.getElementById('flashcard-container').innerHTML = '<h3>Game Over!</h3>';
        if (isHost) {
            document.getElementById('leaderboard').style.display = 'block';
        }
    });

    // Request initial leaderboard
    competitionChannel.subscribe('request-leaderboard', () => {
        if (isHost) {
            fetch(`/api/competition/{{ competition.id }}/leaderboard/`)
                .then(response => response.json())
                .then(data => {
                    competitionChannel.publish('leaderboard', data.leaderboard);
                });
        }
    });

    // Track presence
    competitionChannel.presence.enter('{{ request.user.username }}');

    // Start the game (host only)
    function startGame() {
        let cardIndex = 0;
        const flipTime = 3; // Seconds to show "?"
        const answerTime = 5; // Seconds to answer

        function nextCard() {
            if (cardIndex >= deckData.length) {
                competitionChannel.publish('game-over', {});
                return;
            }
            const card = deckData[cardIndex];
            competitionChannel.publish('card', { card, flip_time: flipTime, answer_time: answerTime });
            cardIndex++;
            setTimeout(nextCard, (flipTime + answerTime + 1) * 1000); // Wait for flip + answer + 1s buffer
        }

        nextCard();
    }

    function showCard(card, flipTime, answerTime) {
        currentCard = card;
        const flashcard = document.querySelector('#flashcard');
        const inner = flashcard.querySelector('.card-inner');
        const front = inner.querySelector('.card-front');
        const back = inner.querySelector('.card-back');
        const options = document.getElementById('options');
        flashcard.classList.remove('flipped');
        front.style.display = 'block';
        back.style.display = 'none';
        options.style.display = 'none';
        front.innerText = '?';
        back.innerText = card.char;
        let timeLeft = flipTime;
        document.getElementById('card-timer').innerText = `Flip in ${timeLeft}s`;

        clearInterval(timer);
        timer = setInterval(() => {
            timeLeft--;
            document.getElementById('card-timer').innerText = `Flip in ${timeLeft}s`;
            if (timeLeft <= 0) {
                clearInterval(timer);
                flashcard.classList.add('flipped');
                front.style.display = 'none';
                back.style.display = 'block';
                options.style.display = 'block';
                options.innerHTML = generateOptions(card);
                startAnswerTimer(card, answerTime);
            }
        }, 1000);
    }

    function startAnswerTimer(card, answerTime) {
        let timeLeft = answerTime;
        document.getElementById('card-timer').innerText = `Answer in ${timeLeft}s`;
        clearInterval(timer);
        timer = setInterval(() => {
            timeLeft--;
            document.getElementById('card-timer').innerText = `Answer in ${timeLeft}s`;
            if (timeLeft <= 0) {
                clearInterval(timer);
                // Auto-submit incorrect if time runs out
                submitAnswer('', card.romaji);
            }
        }, 1000);
    }

    function generateOptions(card) {
        const correct = card.romaji;
        const opts = [correct];
        while (opts.length < 4) {
            const random = deckData[Math.floor(Math.random() * deckData.length)].romaji;
            if (!opts.includes(random)) opts.push(random);
        }
        shuffle(opts);
        return opts.map(opt => `<button class="btn btn-outline-dark m-1" onclick="submitAnswer('${opt}', '${correct}')">${opt}</button>`).join('');
    }

    async function submitAnswer(answer, expected) {
        clearInterval(timer);
        const formData = new FormData();
        formData.append('answer', answer);
        formData.append('question_id', currentCard.id);
        const response = await fetch(`/api/competition/{{ competition.id }}/submit-answer/`, {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': '{{ csrf_token }}'
            }
        });
        const result = await response.json();
        if (result.error) {
            showError(result.error);
        }
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function updateLeaderboard(leaderboard) {
        const tbody = document.getElementById('leaderboard-body');
        tbody.innerHTML = '';
        leaderboard.forEach(p => {
            tbody.innerHTML += `<tr><td>${p.rank}</td><td>${p.username}</td><td>${p.score}</td><td>${p.accuracy}%</td></tr>`;
        });
    }

    function showError(message) {
        const errorDiv = document.getElementById('error-message');
        errorDiv.style.display = 'block';
        errorDiv.innerText = message;
        setTimeout(() => errorDiv.style.display = 'none', 5000);
    }
</script>
<style>
    .card { position: relative; height: 200px; }
    .card-inner { position: relative; width: 100%; height: 100%; }
    .card-front, .card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; font-size: 2rem; background: #e0f7fa; }
    .card-back { transform: rotateY(180deg); }
    .flipped .card-inner { transform: rotateY(180deg); }
</style>
{% endblock %}