{% extends 'base.html' %}
{% load static %}

{% block title %}Katakana Flashcards - Nihonow{% endblock %}

{% block content %}
<!-- Set the page background and custom styles -->
<style>
    body {
        background: linear-gradient(135deg, #fff5f5, #fffde7);
    }
    .container-shadow {
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    .subtype-btn {
        border-color: #1976d2;
        color: #1976d2;
        border-radius: 20px;
        transition: all 0.3s;
    }
    .subtype-btn:hover {
        background-color: #1976d2;
        color: #fff;
    }
    .option-btn {
        border-color: #2c3e50;
        color: #2c3e50;
        border-radius: 15px;
        transition: all 0.3s;
    }
    .option-btn:hover {
        background-color: #1565c0;
        color: #fff;
    }
    .btn-next {
        background-color: #1976d2;
        color: #fff;
        border: none;
        border-radius: 15px;
        transition: all 0.3s;
    }
    .btn-next:hover {
        background-color: #1565c0;
    }
    .btn-back {
        background-color: #ffd700;
        color: #333;
        border: none;
        border-radius: 15px;
        transition: all 0.3s;
    }
    .btn-back:hover {
        background-color: #e6c200;
    }
    .katakana-card {
        max-width: 400px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    .katakana-display {
        font-size: 4.5rem;
    }
    .card-text {
        font-size: 1.1rem;
    }
</style>

<div class="container my-5 container-shadow" style="background: linear-gradient(135deg, #a1c4fd, #c2e9fb); padding: 20px; border-radius: 15px; font-family: 'Noto Sans Japanese', sans-serif;">
    <h2 class="text-center mb-4" style="color: #1976d2; font-size: 2.5rem;">Katakana Flashcards</h2>

    <!-- Selection Section -->
    <div id="selection-section" class="text-center" style="padding: 20px;">
        <h3 class="mb-3" style="color: #1976d2;">Select a Category to Practice</h3>
        <div class="d-flex flex-wrap justify-content-center gap-2">
            <button class="btn subtype-btn" onclick="startFlashcards('basic')">Basic Katakana</button>
            <button class="btn subtype-btn" onclick="startFlashcards('combinations')">Combinations</button>
            <button class="btn subtype-btn" onclick="startFlashcards('tenten')">Tenten/Dakuten</button>
            <button class="btn subtype-btn" onclick="startFlashcards('all')">All</button>
        </div>
    </div>

    <!-- Flashcard Area (Hidden Initially) -->
    <div id="flashcard-section" class="d-none">
        <!-- Score Display -->
        <div class="text-center" style="padding: 20px;">
            <h4 style="color: #1976d2;">Score: <span id="score">0</span> / <span id="total">0</span></h4>
        </div>

        <!-- Katakana Card -->
        <div class="card mb-4 mx-auto katakana-card" style="background-color: #f7f1e3; border: none; padding: 20px;">
            <div class="card-body text-center">
                <h3 id="flashcard-char" class="katakana-display" style="color: #1976d2;"></h3>
                <p class="card-text" style="color: #333;">Choose the correct reading:</p>
            </div>
        </div>

        <!-- Options -->
        <div class="d-flex flex-wrap justify-content-center gap-2" style="padding: 20px;">
            <button class="btn option-btn" data-option="0"></button>
            <button class="btn option-btn" data-option="1"></button>
            <button class="btn option-btn" data-option="2"></button>
            <button class="btn option-btn" data-option="3"></button>
        </div>

        <!-- Feedback -->
        <div id="result" class="text-center" style="padding: 20px;"></div>

        <!-- Next Question Button -->
        <div class="text-center" style="padding: 20px;">
            <button id="next-btn" class="btn btn-next d-none">Next</button>
        </div>

        <!-- Back to Selection Button -->
        <div class="text-center" style="padding: 20px;">
            <button id="back-to-selection-btn" class="btn btn-back">Back to Selection</button>
        </div>
    </div>
</div>

<script>
    // Katakana data
    const katakanaData = {
        basic: [
            { char: 'ア', reading: 'a' }, { char: 'イ', reading: 'i' }, { char: 'ウ', reading: 'u' }, { char: 'エ', reading: 'e' }, { char: 'オ', reading: 'o' },
            { char: 'カ', reading: 'ka' }, { char: 'キ', reading: 'ki' }, { char: 'ク', reading: 'ku' }, { char: 'ケ', reading: 'ke' }, { char: 'コ', reading: 'ko' },
            { char: 'サ', reading: 'sa' }, { char: 'シ', reading: 'shi' }, { char: 'ス', reading: 'su' }, { char: 'セ', reading: 'se' }, { char: 'ソ', reading: 'so' },
            { char: 'タ', reading: 'ta' }, { char: 'チ', reading: 'chi' }, { char: 'ツ', reading: 'tsu' }, { char: 'テ', reading: 'te' }, { char: 'ト', reading: 'to' },
            { char: 'ナ', reading: 'na' }, { char: 'ニ', reading: 'ni' }, { char: 'ヌ', reading: 'nu' }, { char: 'ネ', reading: 'ne' }, { char: 'ノ', reading: 'no' },
            { char: 'ハ', reading: 'ha' }, { char: 'ヒ', reading: 'hi' }, { char: 'フ', reading: 'fu' }, { char: 'ヘ', reading: 'he' }, { char: 'ホ', reading: 'ho' },
            { char: 'マ', reading: 'ma' }, { char: 'ミ', reading: 'mi' }, { char: 'ム', reading: 'mu' }, { char: 'メ', reading: 'me' }, { char: 'モ', reading: 'mo' },
            { char: 'ヤ', reading: 'ya' }, { char: 'ユ', reading: 'yu' }, { char: 'ヨ', reading: 'yo' },
            { char: 'ラ', reading: 'ra' }, { char: 'リ', reading: 'ri' }, { char: 'ル', reading: 'ru' }, { char: 'レ', reading: 're' }, { char: 'ロ', reading: 'ro' },
            { char: 'ワ', reading: 'wa' }, { char: 'ヲ', reading: 'wo' }, { char: 'ン', reading: 'n' }
        ],
        tenten: [
            { char: 'ガ', reading: 'ga' }, { char: 'ギ', reading: 'gi' }, { char: 'グ', reading: 'gu' }, { char: 'ゲ', reading: 'ge' }, { char: 'ゴ', reading: 'go' },
            { char: 'ザ', reading: 'za' }, { char: 'ジ', reading: 'ji' }, { char: 'ズ', reading: 'zu' }, { char: 'ゼ', reading: 'ze' }, { char: 'ゾ', reading: 'zo' },
            { char: 'ダ', reading: 'da' }, { char: 'ヂ', reading: 'ji' }, { char: 'ヅ', reading: 'zu' }, { char: 'デ', reading: 'de' }, { char: 'ド', reading: 'do' },
            { char: 'バ', reading: 'ba' }, { char: 'ビ', reading: 'bi' }, { char: 'ブ', reading: 'bu' }, { char: 'ベ', reading: 'be' }, { char: 'ボ', reading: 'bo' },
            { char: 'パ', reading: 'pa' }, { char: 'ピ', reading: 'pi' }, { char: 'プ', reading: 'pu' }, { char: 'ペ', reading: 'pe' }, { char: 'ポ', reading: 'po' }
        ],
        combinations: [
            { char: 'キャ', reading: 'kya' }, { char: 'キュ', reading: 'kyu' }, { char: 'キョ', reading: 'kyo' },
            { char: 'シャ', reading: 'sha' }, { char: 'シュ', reading: 'shu' }, { char: 'ショ', reading: 'sho' },
            { char: 'チャ', reading: 'cha' }, { char: 'チュ', reading: 'chu' }, { char: 'チョ', reading: 'cho' },
            { char: 'ニャ', reading: 'nya' }, { char: 'ニュ', reading: 'nyu' }, { char: 'ニョ', reading: 'nyo' },
            { char: 'ヒャ', reading: 'hya' }, { char: 'ヒュ', reading: 'hyu' }, { char: 'ヒョ', reading: 'hyo' },
            { char: 'ミャ', reading: 'mya' }, { char: 'ミュ', reading: 'myu' }, { char: 'ミョ', reading: 'myo' },
            { char: 'リャ', reading: 'rya' }, { char: 'リュ', reading: 'ryu' }, { char: 'リョ', reading: 'ryo' },
            { char: 'ギャ', reading: 'gya' }, { char: 'ギュ', reading: 'gyu' }, { char: 'ギョ', reading: 'gyo' },
            { char: 'ジャ', reading: 'ja' }, { char: 'ジュ', reading: 'ju' }, { char: 'ジョ', reading: 'jo' },
            { char: 'ビャ', reading: 'bya' }, { char: 'ビュ', reading: 'byu' }, { char: 'ビョ', reading: 'byo' },
            { char: 'ピャ', reading: 'pya' }, { char: 'ピュ', reading: 'pyu' }, { char: 'ピョ', reading: 'pyo' }
        ]
    };

    let shuffledData = [];
    let currentIndex = 0;
    let score = 0;
    let total = 0;
    let answered = false;
    let options = [];

    // DOM elements
    const selectionSection = document.getElementById('selection-section');
    const flashcardSection = document.getElementById('flashcard-section');
    const flashcardChar = document.getElementById('flashcard-char');
    const optionButtons = document.querySelectorAll('.option-btn');
    const result = document.getElementById('result');
    const nextBtn = document.getElementById('next-btn');
    const backToSelectionBtn = document.getElementById('back-to-selection-btn');
    const scoreDisplay = document.getElementById('score');
    const totalDisplay = document.getElementById('total');

    // Function to shuffle an array (Fisher-Yates algorithm)
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    // Function to save state to sessionStorage
    function saveState() {
        const state = {
            shuffledData: shuffledData,
            currentIndex: currentIndex,
            score: score,
            total: total,
            answered: answered,
            options: options
        };
        sessionStorage.setItem('katakanaFlashcardState', JSON.stringify(state));
    }

    // Function to load state from sessionStorage
    function loadState() {
        const savedState = sessionStorage.getItem('katakanaFlashcardState');
        if (savedState) {
            const state = JSON.parse(savedState);
            shuffledData = state.shuffledData;
            currentIndex = state.currentIndex;
            score = state.score;
            total = state.total;
            answered = state.answered;
            options = state.options;

            // Update DOM
            selectionSection.classList.add('d-none');
            flashcardSection.classList.remove('d-none');
            scoreDisplay.textContent = score;
            totalDisplay.textContent = total;

            // Restore the current flashcard
            if (currentIndex >= shuffledData.length) {
                flashcardChar.textContent = 'Finished!';
                document.querySelector('.card-text').style.display = 'none';
                document.querySelector('.d-flex.flex-wrap.justify-content-center.gap-2').innerHTML = '';
                result.textContent = 'Well done!';
                nextBtn.classList.add('d-none');
            } else {
                const currentChar = shuffledData[currentIndex];
                flashcardChar.textContent = currentChar.char;
                optionButtons.forEach((btn, index) => {
                    btn.textContent = options[index];
                    btn.disabled = answered;
                    if (answered) {
                        const correctReading = currentChar.reading;
                        if (options[index] === correctReading) {
                            btn.classList.remove('option-btn');
                            btn.classList.add('btn-success');
                        } else if (result.textContent.includes(options[index])) {
                            btn.classList.remove('option-btn');
                            btn.classList.add('btn-danger');
                        }
                    }
                });
                if (answered) {
                    const correctReading = currentChar.reading;
                    const selectedOption = options.find(opt => result.textContent.includes(opt));
                    if (selectedOption === correctReading) {
                        result.textContent = 'Correct!';
                        result.style.color = '#28a745';
                    } else {
                        result.textContent = `Incorrect! The correct answer is '${correctReading}'.`;
                        result.style.color = '#dc3545';
                    }
                    nextBtn.classList.remove('d-none');
                }
            }
        }
    }

    // Function to clear state from sessionStorage
    function clearState() {
        sessionStorage.removeItem('katakanaFlashcardState');
    }

    // Function to generate 4 options (1 correct, 3 incorrect)
    function generateOptions(correctChar) {
        const allReadings = katakanaData.all ? katakanaData.all.map(item => item.reading) : Object.values(katakanaData).flat().map(item => item.reading);
        const incorrectOptions = allReadings.filter(r => r !== correctChar.reading);
        const shuffledIncorrect = shuffle(incorrectOptions).slice(0, 3);
        options = [...shuffledIncorrect, correctChar.reading];
        shuffle(options);

        optionButtons.forEach((btn, index) => {
            btn.textContent = options[index];
            btn.disabled = false;
            btn.classList.remove('btn-success', 'btn-danger');
            btn.classList.add('option-btn');
        });
        saveState();
    }

    // Function to display the current katakana and options
    function showFlashcard() {
        if (currentIndex >= shuffledData.length) {
            flashcardChar.textContent = 'Finished!';
            document.querySelector('.card-text').style.display = 'none';
            document.querySelector('.d-flex.flex-wrap.justify-content-center.gap-2').innerHTML = '';
            result.textContent = 'Well done!';
            nextBtn.classList.add('d-none');
            saveState();
            return;
        }

        const currentChar = shuffledData[currentIndex];
        flashcardChar.textContent = currentChar.char;
        generateOptions(currentChar);
        result.textContent = '';
        nextBtn.classList.add('d-none');
        optionButtons.forEach(btn => btn.disabled = false);
    }

    // Function to handle option selection
    function handleOptionSelection(selectedOption) {
        if (answered) return;
        answered = true;

        const selectedReading = options[selectedOption];
        const correctReading = shuffledData[currentIndex].reading;
        optionButtons.forEach(btn => btn.disabled = true);

        if (selectedReading === correctReading) {
            score++;
            result.textContent = 'Correct!';
            result.style.color = '#28a745';
            optionButtons[selectedOption].classList.remove('option-btn');
            optionButtons[selectedOption].classList.add('btn-success');
        } else {
            result.textContent = `Incorrect! The correct answer is '${correctReading}'.`;
            result.style.color = '#dc3545';
            optionButtons[selectedOption].classList.remove('option-btn');
            optionButtons[selectedOption].classList.add('btn-danger');
            const correctIndex = options.indexOf(correctReading);
            optionButtons[correctIndex].classList.remove('option-btn');
            optionButtons[correctIndex].classList.add('btn-success');
        }

        scoreDisplay.textContent = score;
        totalDisplay.textContent = total;
        nextBtn.classList.remove('d-none');
        saveState();
    }

    // Start flashcards
    function startFlashcards(set) {
        if (set === 'basic') shuffledData = [...katakanaData.basic];
        else if (set === 'tenten') shuffledData = [...katakanaData.tenten];
        else if (set === 'combinations') shuffledData = [...katakanaData.combinations];
        else shuffledData = [...katakanaData.basic, ...katakanaData.tenten, ...katakanaData.combinations];

        shuffledData = shuffle(shuffledData);
        total = shuffledData.length;
        currentIndex = 0;
        score = 0;
        answered = false;

        scoreDisplay.textContent = score;
        totalDisplay.textContent = total;

        selectionSection.classList.add('d-none');
        flashcardSection.classList.remove('d-none');
        showFlashcard();
        saveState();
    }

    // Event listeners for option buttons
    optionButtons.forEach((btn, index) => {
        btn.addEventListener('click', () => {
            handleOptionSelection(index);
        });
    });

    // Event listener for Next button
    nextBtn.addEventListener('click', () => {
        currentIndex++;
        answered = false;
        showFlashcard();
    });

    // Event listener for Back to Selection button
    backToSelectionBtn.addEventListener('click', () => {
        flashcardSection.classList.add('d-none');
        selectionSection.classList.remove('d-none');
        result.textContent = '';
        currentIndex = 0;
        score = 0;
        total = 0;
        scoreDisplay.textContent = score;
        totalDisplay.textContent = total;
        clearState();
    });

    // Load state on page load
    window.addEventListener('load', () => {
        loadState();
    });
</script>
{% endblock %}